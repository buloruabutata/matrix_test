# generate_data.py (最终版)
# Python脚本：生成RISC-V汇编数据文件和tile操作代码

import os
import random
from pathlib import Path


def generate_riscv_data(test_config, output_dir="build"):
    """
    生成RISC-V汇编数据文件，包含数据定义和tile操作代码

    参数:
    array_name: 数组名称
    data: 数据列表
    test_config["width"]: 数据宽度 (8, 16, 32, 64)
    output_dir: 输出目录（相对于脚本位置）
    """

    # 指令映射表
    directive_map = {8: ".byte", 16: ".half", 32: ".word", 64: ".dword"}  # 或 .quad

    # 格式化函数映射
    format_func = {
        8: lambda x: f"0x{x:02X}",
        16: lambda x: f"0x{x:04X}",
        32: lambda x: f"0x{x:08X}",
        64: lambda x: f"0x{x:016X}",
    }

    # 验证参数
    if test_config["width"] not in directive_map:
        raise ValueError(
            f"Unsupported data width: {test_config['width']}. Use 8, 16, 32, or 64"
        )

    if not test_config["data"]:
        raise ValueError("Data list cannot be empty")

    # 创建输出目录
    script_dir = Path(__file__).parent
    output_path = script_dir / output_dir
    output_path.mkdir(exist_ok=True)  # 创建目录（如果不存在）

    # 生成文件名
    filename = f"{test_config['name']}.s"
    output_file = output_path / filename

    # 生成汇编代码
    with open(output_file, "w") as f:
        f.write(f"# Generated by Python - {test_config['name']}\n")
        f.write(f"# Data width: {test_config['width']} bits\n")
        f.write(f"# Element count: {len(test_config['data'])}\n")
        f.write(
            f"# Total size: {len(test_config['data']) * (test_config['width'] // 8)} bytes\n"
        )
        f.write(f"# Format: Hexadecimal (0x...)\n\n")

        # ==================== 数据定义部分 ====================
        f.write(f"# ------------------- Data Definition -------------------\n")
        f.write(f".data\n")
        # 数组开始标签
        f.write(f"{test_config['name']}:\n")

        # 选择正确的汇编指令和格式化函数
        directive = directive_map[test_config["width"]]
        formatter = format_func[test_config["width"]]

        # 每行写入多个值以提高可读性
        values_per_line = {
            8: 12,  # 每行12个byte (保持行宽适中)
            16: 8,  # 每行8个half
            32: 4,  # 每行4个word
            64: 2,  # 每行2个dword
        }

        current_line = []
        for i, value in enumerate(test_config["data"]):
            # 验证数据范围
            max_val = (1 << test_config["width"]) - 1
            if value < 0 or value > max_val:
                raise ValueError(
                    f"Value {value} out of range for {test_config['width']}-bit"
                )

            # 使用16进制格式
            hex_value = formatter(value)
            current_line.append(hex_value)

            # 每行写入指定数量的值
            if len(current_line) >= values_per_line[test_config["width"]]:
                f.write(f"    {directive} {', '.join(current_line)}\n")
                current_line = []

        # 写入剩余的值
        if current_line:
            f.write(f"    {directive} {', '.join(current_line)}\n")

        # 数组结束标签
        f.write(f"{test_config['name']}_end:\n\n")

        # ==================== Tile操作代码部分 ====================
        f.write(f"# ------------------- Tile Operations -------------------\n")
        f.write(f"# TILE configuration for {test_config['width']}-bit processing\n")
        f.write(f".text\n")
        f.write(f"_start:\n")
        f.write(f"    msettilemi t0, 0x{test_config['m']:X}\n")
        f.write(f"    msettileki t0, 0x{test_config['n']:X}\n")
        f.write(f"    msettileni t0, 0x{test_config['k']:X}\n")
        f.write(f"    li t1, {test_config['width']}\n")
        f.write(f"    la t0, {test_config['name']}\n")
        f.write(f"    mlae{test_config['width']:d}.m tr1, (t0), t1\n")
        f.write(f"    mlate{test_config['width']:d}.m tr1, (t0), t1\n")
        f.write(f"    mlbe{test_config['width']:d}.m tr1, (t0), t1\n")
        f.write(f"    mlbte{test_config['width']:d}.m tr1, (t0), t1\n")
        f.write(f"    mltre{test_config['width']:d}.m tr1, (t0), t1\n")
        f.write(f"    mlacce{test_config['width']:d}.m acc1, (t0), t1\n")
        # 使用m5_exit 系统调用号退出程序
        f.write(f"    li a0, 0\n")
        f.write(f"    li a7, 10\n")
        f.write(f"    ecall\n")


# === 使用示例 ===
if __name__ == "__main__":
    # 设置随机种子确保可重现
    random.seed(42)
    size = 64

    # 定义测试数据
    test_configs = [
        {
            "name": "samples_8bit",
            "data": [random.randint(0, 255) for _ in range(size)],
            "width": 8,
            "m": 8,
            "n": 8,
            "k": 8,
        },
        {
            "name": "samples_16bit",
            "data": [random.randint(0, 65535) for _ in range(size)],
            "width": 16,
            "m": 8,
            "n": 8,
            "k": 8,
        },
        {
            "name": "samples_32bit",
            "data": [random.randint(0, 2**32 - 1) for _ in range(size)],
            "width": 32,
            "m": 8,
            "n": 8,
            "k": 8,
        },
        {
            "name": "samples_64bit",
            "data": [random.randint(0, 2**64 - 1) for _ in range(size)],
            "width": 64,
            "m": 8,
            "n": 8,
            "k": 8,
        },
    ]

    # 生成所有数据文件
    for config in test_configs:
        generate_riscv_data(
            config,
        )
        print(f"Generated build/{config['name']}.s for {config['width']}-bit data")

    print(f"\nAll files generated in './build/' directory")
    print(f"Files created:")
    for file in Path("build").glob("*.s"):
        print(f"  - {file}")
